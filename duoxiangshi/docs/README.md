# ä¼˜åŒ–ç‰ˆæ¡ä»¶å¤šé¡¹å¼è§„åˆ™å‘ç°å·¥å…·

ä¸€ä¸ªæ™ºèƒ½çš„æ•°æ®æŒ–æ˜å·¥å…·ï¼Œèƒ½å¤Ÿè‡ªåŠ¨å‘ç°æ•°æ®ä¸­çš„**æ¡ä»¶å¤šé¡¹å¼è§„åˆ™**ï¼Œæ”¯æŒæ•°å€¼å’Œåˆ†ç±»ç‰¹å¾çš„æ··åˆåˆ†æã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### ä»€ä¹ˆæ˜¯æ¡ä»¶å¤šé¡¹å¼è§„åˆ™ï¼Ÿ

ç®€å•æ¥è¯´ï¼Œå°±æ˜¯åœ¨ä¸åŒæ¡ä»¶ä¸‹ï¼Œå˜é‡ä¹‹é—´å­˜åœ¨ä¸åŒçš„çº¿æ€§å…³ç³»ã€‚ä¾‹å¦‚ï¼š

```
å½“ temperature <= 25Â°C æ—¶ï¼šenergy_cost = 2*area + 1.5*occupancy + 100
å½“ temperature > 25Â°C æ—¶ï¼šenergy_cost = 3*area + 2.0*occupancy + 150

å½“ product_type = 'A' ä¸” region âˆˆ {North, East} æ—¶ï¼šsales = 1.2*price + 0.8*marketing + 50
å½“ product_type âˆˆ {'B', 'C'} æ—¶ï¼šsales = 0.9*price + 1.5*marketing + 80
```

### ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ªå·¥å…·ï¼Ÿ

åœ¨ç°å®ä¸–ç•Œä¸­ï¼Œå˜é‡å…³ç³»å¾€å¾€ä¸æ˜¯ä¸€æˆä¸å˜çš„ï¼š
- **å­£èŠ‚æ€§å½±å“**ï¼šå¤å­£å’Œå†¬å­£çš„èƒ½è€—æ¨¡å¼ä¸åŒ
- **äº§å“å·®å¼‚**ï¼šä¸åŒç±»å‹äº§å“çš„é”€å”®è§„å¾‹ä¸åŒ  
- **åŒºåŸŸç‰¹æ€§**ï¼šä¸åŒåœ°åŒºçš„å¸‚åœºè¡Œä¸ºä¸åŒ
- **ç”¨æˆ·åˆ†ç¾¤**ï¼šä¸åŒç”¨æˆ·ç¾¤ä½“çš„è¡Œä¸ºæ¨¡å¼ä¸åŒ

ä¼ ç»Ÿçš„å…¨å±€çº¿æ€§å›å½’æ— æ³•æ•æ‰è¿™äº›**åˆ†æ®µçº¿æ€§å…³ç³»**ï¼Œè€Œæˆ‘ä»¬çš„å·¥å…·ä¸“é—¨è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

## ğŸ”¬ æŠ€æœ¯æ–¹æ¡ˆ

### ç®—æ³•åŸç†

æˆ‘ä»¬çš„æ–¹æ³•é‡‡ç”¨**"åˆ†è€Œæ²»ä¹‹"**çš„ç­–ç•¥ï¼š

1. **æ™ºèƒ½åˆ†æ®µ**ï¼šä½¿ç”¨å†³ç­–æ ‘è‡ªåŠ¨å‘ç°æ•°æ®çš„æœ€ä½³åˆ†æ®µç‚¹
2. **å±€éƒ¨å»ºæ¨¡**ï¼šåœ¨æ¯ä¸ªåˆ†æ®µå†…æ‹Ÿåˆçº¿æ€§æ¨¡å‹
3. **å…¨å±€ä¼˜åŒ–**ï¼šç©·ä¸¾æ‰€æœ‰å¯èƒ½çš„ç‰¹å¾ç»„åˆï¼Œæ‰¾åˆ°æœ€ä¼˜è§£

```mermaid
flowchart TD
    A[CSVæ•°æ®åŠ è½½] --> B[ç‰¹å¾ç±»å‹è¯†åˆ«]
    B --> C{æ•°å€¼ç‰¹å¾ vs åˆ†ç±»ç‰¹å¾}
    C --> D[åˆ†ç±»ç‰¹å¾æ ‡ç­¾ç¼–ç ]
    D --> E[ç‰¹å¾ç»„åˆç”Ÿæˆ]
    E --> F{ç©·ä¸¾ vs å¯å‘å¼}
    F -->|ç©·ä¸¾æœç´¢| G[æ‰€æœ‰å¯èƒ½ç»„åˆ]
    F -->|å¯å‘å¼| H[ç­›é€‰é«˜è´¨é‡ç»„åˆ]
    G --> I[ç»„åˆè¯„ä¼°å¾ªç¯]
    H --> I
    I --> J[å†³ç­–æ ‘åˆ†æ®µ]
    J --> K[æ¡ä»¶è·¯å¾„æå–]
    K --> L[æ¯ä¸ªåˆ†æ®µçº¿æ€§æ‹Ÿåˆ]
    L --> M[äº¤å‰éªŒè¯è¯„ä¼°]
    M --> N{æ˜¯å¦æœ€ä¼˜ç»„åˆ?}
    N -->|å¦| I
    N -->|æ˜¯| O[æ›´æ–°æœ€ä½³ç»“æœ]
    O --> P{è¿˜æœ‰ç»„åˆ?}
    P -->|æ˜¯| I
    P -->|å¦| Q[è¾“å‡ºæœ€ä¼˜è§„åˆ™]
    Q --> R[è§„åˆ™å±•ç¤ºä¸åˆ†æ]
    
    style A fill:#e1f5fe
    style Q fill:#c8e6c9
    style R fill:#c8e6c9
    style J fill:#fff3e0
    style L fill:#fff3e0
    style M fill:#fce4ec
```

### æ ¸å¿ƒåˆ›æ–°

#### 1. æ™ºèƒ½ç‰¹å¾ç»„åˆç©·ä¸¾
```python
# ä¸å†åªå°è¯•ä¸€ç§ç‰¹å¾åˆ†é…ï¼Œè€Œæ˜¯ç©·ä¸¾æ‰€æœ‰å¯èƒ½çš„ç»„åˆ
for split_size in range(1, min(len(split_candidates), 4) + 1):
    for split_features in combinations(split_candidates, split_size):
        poly_features = [f for f in poly_candidates if f not in split_features]
        # è¯„ä¼°è¿™ç§ç»„åˆçš„æ•ˆæœ
```

**ä¼˜åŠ¿**ï¼šç¡®ä¿æ‰¾åˆ°æœ€ä¼˜çš„ç‰¹å¾åˆ†é…ï¼Œä¸ä¼šé”™è¿‡ä»»ä½•æœ‰ä»·å€¼çš„ç»„åˆã€‚

### ğŸŒ³ å†³ç­–æ ‘åˆ†æ®µåŸç†æ·±åº¦è§£æ

#### ä¸ºä»€ä¹ˆç”¨å†³ç­–æ ‘åšåˆ†æ®µï¼Ÿ

ä¼ ç»Ÿçš„æ‰‹å·¥åˆ†æ®µéœ€è¦äººä¸ºè®¾å®šé˜ˆå€¼ï¼Œæ¯”å¦‚"æ¸©åº¦>30Â°C"æˆ–"ä»·æ ¼åœ¨100-200åŒºé—´"ã€‚ä½†è¿™æ ·åšæœ‰ä¸‰ä¸ªé—®é¢˜ï¼š
1. **ä¸»è§‚æ€§å¼º** - é˜ˆå€¼è®¾å®šç¼ºä¹æ•°æ®æ”¯æ’‘
2. **ç»´åº¦è¯…å’’** - å¤šç‰¹å¾ç»„åˆçš„é˜ˆå€¼è®¾å®šæŒ‡æ•°çº§å¤æ‚
3. **å±€éƒ¨æœ€ä¼˜** - å¯èƒ½é”™è¿‡çœŸæ­£çš„æœ€ä½³åˆ†æ®µç‚¹

å†³ç­–æ ‘é€šè¿‡**ä¿¡æ¯å¢ç›Š**è‡ªåŠ¨æ‰¾åˆ°æœ€ä½³åˆ†æ®µç‚¹ï¼Œè®©æ•°æ®"è‡ªå·±è¯´è¯"ã€‚

#### æ ¸å¿ƒç®—æ³•æµç¨‹

è®©æˆ‘ä»¬é€šè¿‡ä»£ç æ¥çœ‹æ•´ä¸ªè¿‡ç¨‹ï¼š

**æ­¥éª¤1ï¼šè®­ç»ƒå†³ç­–æ ‘æ¨¡å‹**
```python
def _evaluate_combination(self, data, split_features, poly_features, target_col):
    # å‡†å¤‡åˆ†æ®µç‰¹å¾ä½œä¸ºè¾“å…¥
    X_split = data[split_features]  # ä¾‹å¦‚ï¼štemperature, product_type
    y_target = data[target_col]     # ä¾‹å¦‚ï¼šenergy_cost
    
    # è®­ç»ƒå†³ç­–æ ‘å›å½’å™¨
    tree_model = DecisionTreeRegressor(
        max_depth=self.max_depth,           # æ§åˆ¶æ ‘çš„æ·±åº¦ï¼Œé˜²æ­¢è¿‡æ‹Ÿåˆ
        min_samples_leaf=self.min_samples_leaf,  # å¶å­èŠ‚ç‚¹æœ€å°æ ·æœ¬æ•°
        random_state=42                     # ä¿è¯ç»“æœå¯é‡å¤
    )
    
    tree_model.fit(X_split, y_target)
```

**å…³é”®å‚æ•°è§£é‡Šï¼š**
- `max_depth=3`ï¼šé™åˆ¶æ ‘çš„æ·±åº¦ï¼Œé¿å…è¿‡åº¦ç»†åˆ†
- `min_samples_leaf=50`ï¼šç¡®ä¿æ¯ä¸ªåˆ†æ®µæœ‰è¶³å¤Ÿæ ·æœ¬ï¼Œä¿è¯ç»Ÿè®¡æ„ä¹‰

**æ­¥éª¤2ï¼šæå–åˆ†æ®µæ¡ä»¶**
```python
# è·å–æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„æ¡ä»¶è·¯å¾„
conditions_by_leaf = self._extract_tree_conditions(tree_model, split_features, data)
# è·å–æ¯ä¸ªæ ·æœ¬æ‰€å±çš„å¶å­èŠ‚ç‚¹ID
leaf_ids = tree_model.apply(X_split)
```

**æ­¥éª¤3ï¼šä»å†³ç­–æ ‘ä¸­æå–ç²¾ç¡®æ¡ä»¶**

è¿™æ˜¯æœ€å¤æ‚çš„éƒ¨åˆ†ï¼Œéœ€è¦é€’å½’éå†å†³ç­–æ ‘ï¼š

```python
def _extract_tree_conditions(self, tree_model, feature_names, original_data):
    tree = tree_model.tree_
    conditions_by_leaf = {}
    
    def extract_path(node_id, conditions):
        # å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œè®°å½•åˆ°è¾¾æ­¤å¤„çš„æ‰€æœ‰æ¡ä»¶
        if tree.children_left[node_id] == -1:  
            conditions_by_leaf[node_id] = conditions.copy()
            return
            
        # è·å–å½“å‰èŠ‚ç‚¹çš„åˆ†è£‚ä¿¡æ¯
        feature_idx = tree.feature[node_id]      # åˆ†è£‚ç‰¹å¾çš„ç´¢å¼•
        threshold = tree.threshold[node_id]      # åˆ†è£‚é˜ˆå€¼
        feature_name = feature_names[feature_idx] # ç‰¹å¾åç§°
        
        # å¤„ç†åˆ†ç±»ç‰¹å¾å’Œæ•°å€¼ç‰¹å¾çš„ä¸åŒé€»è¾‘
        if feature_name in self.categorical_features:
            # åˆ†ç±»ç‰¹å¾å¤„ç†é€»è¾‘...
        else:
            # æ•°å€¼ç‰¹å¾ï¼šç”Ÿæˆ <= å’Œ > æ¡ä»¶
            left_conditions = conditions + [f"{feature_name} <= {threshold:.2f}"]
            extract_path(tree.children_left[node_id], left_conditions)
            
            right_conditions = conditions + [f"{feature_name} > {threshold:.2f}"]
            extract_path(tree.children_right[node_id], right_conditions)
    
    extract_path(0, [])  # ä»æ ¹èŠ‚ç‚¹å¼€å§‹é€’å½’
    return conditions_by_leaf
```

#### ğŸ” å…·ä½“ç¤ºä¾‹ï¼šæ¸©åº¦-ç©ºè°ƒç±»å‹åˆ†æ®µ

å‡è®¾æˆ‘ä»¬æœ‰è¿™æ ·çš„æ•°æ®ï¼š
```python
temperature: [15, 20, 25, 30, 35]
ac_type:     [A,  A,  B,  A,  B]
energy_cost: [100, 120, 200, 180, 250]
```

**å†³ç­–æ ‘å­¦ä¹ è¿‡ç¨‹ï¼š**

1. **æ ¹èŠ‚ç‚¹åˆ†è£‚**ï¼šç®—æ³•å‘ç° `temperature <= 27.5` èƒ½æœ€å¥½åœ°åˆ†ç¦»æ•°æ®
2. **å·¦åˆ†æ”¯**ï¼š`temperature <= 27.5` çš„æ ·æœ¬èƒ½è€—ç›¸å¯¹è¾ƒä½
3. **å³åˆ†æ”¯**ï¼š`temperature > 27.5` çš„æ ·æœ¬éœ€è¦è¿›ä¸€æ­¥æŒ‰ `ac_type` åˆ†ç±»

æœ€ç»ˆå¾—åˆ°å†³ç­–æ ‘ï¼š
```
                  temperature <= 27.5
                      /           \
                    YES            NO
                 [è¾ƒä½èƒ½è€—]    ac_type âˆˆ {A}
                               /          \
                             YES          NO
                        [ä¸­ç­‰èƒ½è€—A]    [é«˜èƒ½è€—B]
```

**æå–çš„æ¡ä»¶è·¯å¾„ï¼š**
- å¶å­1ï¼š`temperature <= 27.5` 
- å¶å­2ï¼š`temperature > 27.5 ä¸” ac_type âˆˆ {A}`
- å¶å­3ï¼š`temperature > 27.5 ä¸” ac_type âˆˆ {B}`

#### ğŸ·ï¸ åˆ†ç±»ç‰¹å¾çš„ç‰¹æ®Šå¤„ç†

åˆ†ç±»ç‰¹å¾ï¼ˆå¦‚äº§å“ç±»å‹ã€åœ°åŒºï¼‰éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œå› ä¸ºå†³ç­–æ ‘å†…éƒ¨ç”¨æ•°å€¼ç¼–ç ï¼š

```python
if feature_name in self.categorical_features:
    # è·å–ç¼–ç å™¨ï¼Œå°†æ•°å€¼é˜ˆå€¼è½¬æ¢å›åŸå§‹åˆ†ç±»å€¼
    le = self.label_encoders[feature_name]
    
    # æ ¹æ®é˜ˆå€¼åˆ†ç»„
    left_values = [val for val in unique_encoded_values if val <= threshold]
    right_values = [val for val in unique_encoded_values if val > threshold]
    
    # è½¬æ¢å›åŸå§‹åˆ†ç±»å€¼å¹¶æ ¼å¼åŒ–
    if left_values:
        left_original = [le.inverse_transform([int(val)])[0] for val in left_values]
        left_condition = f"{feature_name} âˆˆ {{{', '.join(map(str, left_original))}}}"
```

**ä¸¾ä¾‹è¯´æ˜ï¼š**
- åŸå§‹æ•°æ®ï¼š`product_type = ['A', 'B', 'C']`
- ç¼–ç åï¼š`[0, 1, 2]`
- å†³ç­–æ ‘åˆ†è£‚ï¼š`threshold = 1.5`
- è½¬æ¢å›æ¥ï¼š
  - å·¦åˆ†æ”¯ï¼š`product_type âˆˆ {A, B}` (ç¼–ç å€¼ â‰¤ 1.5)
  - å³åˆ†æ”¯ï¼š`product_type âˆˆ {C}` (ç¼–ç å€¼ > 1.5)

#### ğŸ¯ åˆ†æ®µè´¨é‡è¯„ä¼°

æ‰¾åˆ°åˆ†æ®µåï¼Œåœ¨æ¯ä¸ªåˆ†æ®µå†…æ‹Ÿåˆçº¿æ€§æ¨¡å‹ï¼š

```python
# å¯¹æ¯ä¸ªå¶å­èŠ‚ç‚¹ï¼ˆåˆ†æ®µï¼‰
for leaf_id, conditions in conditions_by_leaf.items():
    subset_mask = (leaf_ids == leaf_id)
    subset_data = data[subset_mask]
    
    # åœ¨è¯¥åˆ†æ®µå†…æ‹Ÿåˆå¤šé¡¹å¼æ¨¡å‹
    X_poly = subset_data[poly_features]  # å¤šé¡¹å¼ç‰¹å¾
    y_poly = subset_data[target_col]     # ç›®æ ‡å˜é‡
    
    # äº¤å‰éªŒè¯è¯„ä¼°æ‹Ÿåˆè´¨é‡
    model = LinearRegression()
    cv_scores = cross_val_score(model, X_poly, y_poly, cv=3, scoring='r2')
    avg_score = np.mean(cv_scores)
```

#### ğŸ† ä¸ºä»€ä¹ˆè¿™ç§æ–¹æ³•æœ‰æ•ˆï¼Ÿ

1. **æ•°æ®é©±åŠ¨**ï¼šåˆ†æ®µç‚¹ç”±æ•°æ®çš„å†…åœ¨è§„å¾‹å†³å®šï¼Œä¸æ˜¯äººä¸ºè®¾å®š
2. **è‡ªåŠ¨ä¼˜åŒ–**ï¼šä¿¡æ¯å¢ç›Šç¡®ä¿æ¯æ¬¡åˆ†è£‚éƒ½èƒ½æœ€å¤§åŒ–ç›®æ ‡å˜é‡çš„è§£é‡Šåº¦
3. **å¤šç»´å¤„ç†**ï¼šå¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ªç‰¹å¾çš„å¤æ‚äº¤äº’
4. **è´¨é‡ä¿è¯**ï¼šäº¤å‰éªŒè¯ç¡®ä¿åˆ†æ®µåœ¨æ–°æ•°æ®ä¸Šä¹Ÿæœ‰æ•ˆ

**å¯¹æ¯”ä¼ ç»Ÿæ–¹æ³•ï¼š**
| æ–¹æ³• | åˆ†æ®µæ–¹å¼ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|------|------|
| æ‰‹å·¥åˆ†æ®µ | ç»éªŒè®¾å®šé˜ˆå€¼ | ç®€å•ç›´è§‚ | ä¸»è§‚æ€§å¼ºï¼Œæ˜“é”™è¿‡æœ€ä¼˜ç‚¹ |
| èšç±»åˆ†æ®µ | K-meansç­‰ | æ— ç›‘ç£ | ä¸è€ƒè™‘ç›®æ ‡å˜é‡ |
| **å†³ç­–æ ‘åˆ†æ®µ** | **ä¿¡æ¯å¢ç›Šä¼˜åŒ–** | **å®¢è§‚ã€æœ€ä¼˜ã€å¤šç»´** | **è®¡ç®—å¤æ‚åº¦è¾ƒé«˜** |

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬çš„å·¥å…·èƒ½å¤Ÿå‘ç°ä¼ ç»Ÿæ–¹æ³•é—æ¼çš„å¤æ‚åˆ†æ®µæ¨¡å¼ï¼Œä¸ºä¸šåŠ¡æä¾›æ›´ç²¾ç¡®çš„å¯è§£é‡Šè§„åˆ™ï¼

### ğŸ”€ å¤šç‰¹å¾åˆ†æ®µï¼šå¤„ç†å¤æ‚äº¤äº’

#### å¤šç‰¹å¾åˆ†æ®µçš„æŒ‘æˆ˜

å½“æˆ‘ä»¬æœ‰å¤šä¸ªç‰¹å¾ä½œä¸ºåˆ†æ®µæ¡ä»¶æ—¶ï¼Œæ¯”å¦‚ `[temperature, humidity, product_type]`ï¼Œé—®é¢˜å˜å¾—å¤æ‚ï¼š

1. **ç‰¹å¾é€‰æ‹©**ï¼šåœ¨æ¯ä¸ªèŠ‚ç‚¹ï¼Œåº”è¯¥é€‰æ‹©å“ªä¸ªç‰¹å¾è¿›è¡Œåˆ†è£‚ï¼Ÿ
2. **é˜ˆå€¼ä¼˜åŒ–**ï¼šé€‰å®šç‰¹å¾åï¼Œæœ€ä½³åˆ†è£‚é˜ˆå€¼æ˜¯ä»€ä¹ˆï¼Ÿ  
3. **äº¤äº’å‘ç°**ï¼šå¦‚ä½•æ•æ‰ç‰¹å¾ä¹‹é—´çš„äº¤äº’ä½œç”¨ï¼Ÿ
4. **ç»´åº¦çˆ†ç‚¸**ï¼šå¦‚ä½•é¿å…è¿‡åº¦å¤æ‚çš„åˆ†æ®µè§„åˆ™ï¼Ÿ

#### ğŸ§  å†³ç­–æ ‘çš„æ™ºèƒ½åˆ†è£‚ç­–ç•¥

å†³ç­–æ ‘é€šè¿‡**è´ªå¿ƒç®—æ³•**åœ¨æ¯ä¸ªèŠ‚ç‚¹è‡ªåŠ¨è§£å†³è¿™äº›é—®é¢˜ï¼š

**æ ¸å¿ƒåŸç†ï¼šä¿¡æ¯å¢ç›Šæœ€å¤§åŒ–**

```python
# ä¼ªä»£ç ï¼šå†³ç­–æ ‘åˆ†è£‚è¿‡ç¨‹
def find_best_split(X_features, y_target):
    best_gain = -1
    best_feature = None
    best_threshold = None
    
    # éå†æ‰€æœ‰å¯èƒ½çš„ç‰¹å¾
    for feature in X_features.columns:
        # éå†è¯¥ç‰¹å¾çš„æ‰€æœ‰å¯èƒ½åˆ†è£‚ç‚¹
        for threshold in get_candidate_thresholds(X_features[feature]):
            # è®¡ç®—æŒ‰æ­¤ç‰¹å¾å’Œé˜ˆå€¼åˆ†è£‚åçš„ä¿¡æ¯å¢ç›Š
            gain = calculate_information_gain(X_features, y_target, feature, threshold)
            
            if gain > best_gain:
                best_gain = gain
                best_feature = feature
                best_threshold = threshold
    
    return best_feature, best_threshold
```

#### ğŸ“Š å…·ä½“ç¤ºä¾‹ï¼šæ¸©åº¦+æ¹¿åº¦+äº§å“ç±»å‹åˆ†æ®µ

å‡è®¾æˆ‘ä»¬è¦åˆ†æç©ºè°ƒèƒ½è€—ï¼Œæœ‰ä¸‰ä¸ªåˆ†æ®µç‰¹å¾ï¼š

```python
# è®­ç»ƒæ•°æ®
data = {
    'temperature': [15, 20, 25, 30, 35, 18, 28, 32],
    'humidity':    [40, 45, 50, 60, 70, 35, 65, 75], 
    'product_type':['A', 'A', 'B', 'A', 'B', 'A', 'B', 'B'],
    'energy_cost': [100, 110, 180, 160, 250, 95, 200, 280]
}

# å¤šç‰¹å¾åˆ†æ®µ
X_split = data[['temperature', 'humidity', 'product_type']]
y_target = data['energy_cost']
```

**å†³ç­–æ ‘å­¦ä¹ è¿‡ç¨‹ï¼š**

```mermaid
graph TD
    A[æ ¹èŠ‚ç‚¹: æ‰€æœ‰æ ·æœ¬<br/>å¹³å‡èƒ½è€—=171.25] --> B{é€‰æ‹©æœ€ä¼˜åˆ†è£‚}
    B --> C[éå†temperatureé˜ˆå€¼]
    B --> D[éå†humidityé˜ˆå€¼] 
    B --> E[éå†product_typeç±»åˆ«]
    
    C --> F[temperature <= 26.0<br/>ä¿¡æ¯å¢ç›Š=0.45]
    D --> G[humidity <= 55.0<br/>ä¿¡æ¯å¢ç›Š=0.32]
    E --> H[product_type âˆˆ {A}<br/>ä¿¡æ¯å¢ç›Š=0.38]
    
    F --> I[é€‰æ‹©æœ€ä¼˜: temperature <= 26.0]
    
    I --> J[å·¦å­æ ‘: temperature <= 26.0<br/>æ ·æœ¬: [100,110,160,95]<br/>å¹³å‡èƒ½è€—=116.25]
    I --> K[å³å­æ ‘: temperature > 26.0<br/>æ ·æœ¬: [180,250,200,280]<br/>å¹³å‡èƒ½è€—=227.5]
    
    J --> L{ç»§ç»­åˆ†è£‚å·¦å­æ ‘}
    K --> M{ç»§ç»­åˆ†è£‚å³å­æ ‘}
    
    L --> N[product_type âˆˆ {A}<br/>è¿›ä¸€æ­¥ç»†åˆ†]
    M --> O[humidity <= 67.5<br/>è¿›ä¸€æ­¥ç»†åˆ†]
    
    style I fill:#ffeb3b
    style F fill:#4caf50
    style N fill:#2196f3
    style O fill:#2196f3
```

#### ğŸ” åˆ†è£‚å†³ç­–çš„è¯¦ç»†è¿‡ç¨‹

**æ­¥éª¤1ï¼šæ ¹èŠ‚ç‚¹åˆ†è£‚**

å†³ç­–æ ‘è¯„ä¼°æ‰€æœ‰å¯èƒ½çš„åˆ†è£‚ï¼š

```python
# å€™é€‰åˆ†è£‚ç‚¹è¯„ä¼°
candidates = [
    ('temperature', 22.5, gain=0.31),
    ('temperature', 26.0, gain=0.45),  # æœ€ä¼˜
    ('temperature', 29.0, gain=0.28),
    ('humidity', 47.5, gain=0.25),
    ('humidity', 55.0, gain=0.32),
    ('product_type', {A}, gain=0.38),
]

# é€‰æ‹©ä¿¡æ¯å¢ç›Šæœ€å¤§çš„åˆ†è£‚
best_split = ('temperature', 26.0, gain=0.45)
```

**ä¿¡æ¯å¢ç›Šè®¡ç®—ï¼š**
```python
def calculate_information_gain(X, y, feature, threshold):
    # åˆ†è£‚å‰çš„æ–¹å·®ï¼ˆåŸºå‡†ï¼‰
    total_variance = np.var(y)
    
    # æŒ‰ç‰¹å¾å’Œé˜ˆå€¼åˆ†è£‚
    if feature in categorical_features:
        left_mask = X[feature].isin(threshold)  # thresholdæ˜¯ç±»åˆ«é›†åˆ
    else:
        left_mask = X[feature] <= threshold
    
    # è®¡ç®—åˆ†è£‚åå„å­é›†çš„åŠ æƒæ–¹å·®
    left_variance = np.var(y[left_mask]) if sum(left_mask) > 0 else 0
    right_variance = np.var(y[~left_mask]) if sum(~left_mask) > 0 else 0
    
    left_weight = sum(left_mask) / len(y)
    right_weight = sum(~left_mask) / len(y)
    
    weighted_variance = left_weight * left_variance + right_weight * right_variance
    
    # ä¿¡æ¯å¢ç›Š = æ–¹å·®å‡å°‘é‡
    information_gain = total_variance - weighted_variance
    return information_gain
```

**æ­¥éª¤2ï¼šå­èŠ‚ç‚¹ç»§ç»­åˆ†è£‚**

å·¦å­æ ‘ (`temperature <= 26.0`) ç»§ç»­é€‰æ‹©æœ€ä¼˜åˆ†è£‚ï¼š
```python
# å·¦å­æ ‘å€™é€‰åˆ†è£‚
left_candidates = [
    ('humidity', 42.5, gain=0.15),
    ('product_type', {A}, gain=0.22),  # æœ€ä¼˜
]
```

å³å­æ ‘ (`temperature > 26.0`) ç»§ç»­é€‰æ‹©ï¼š
```python
# å³å­æ ‘å€™é€‰åˆ†è£‚  
right_candidates = [
    ('humidity', 67.5, gain=0.31),  # æœ€ä¼˜
    ('product_type', {B}, gain=0.18),
]
```

#### ğŸ¯ æœ€ç»ˆåˆ†æ®µè§„åˆ™æå–

ç»è¿‡é€’å½’åˆ†è£‚ï¼Œå¾—åˆ°å¶å­èŠ‚ç‚¹çš„å®Œæ•´æ¡ä»¶è·¯å¾„ï¼š

```python
# æå–çš„åˆ†æ®µæ¡ä»¶
segments = {
    'segment_1': {
        'conditions': ['temperature <= 26.0', 'product_type âˆˆ {A}'],
        'samples': [100, 110, 95],
        'avg_cost': 101.67
    },
    'segment_2': {
        'conditions': ['temperature <= 26.0', 'product_type âˆˆ {B}'], 
        'samples': [160],
        'avg_cost': 160.0
    },
    'segment_3': {
        'conditions': ['temperature > 26.0', 'humidity <= 67.5'],
        'samples': [180, 200],
        'avg_cost': 190.0  
    },
    'segment_4': {
        'conditions': ['temperature > 26.0', 'humidity > 67.5'],
        'samples': [250, 280],
        'avg_cost': 265.0
    }
}
```

#### ğŸ”‘ å…³é”®æŠ€æœ¯ç‰¹ç‚¹

**1. è‡ªé€‚åº”ç‰¹å¾é€‰æ‹©**
```python
# å†³ç­–æ ‘åœ¨æ¯ä¸ªèŠ‚ç‚¹è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ç‰¹å¾
# ä¸éœ€è¦é¢„å…ˆæŒ‡å®šç‰¹å¾çš„ä¼˜å…ˆçº§æˆ–é¡ºåº
for node in tree_nodes:
    best_feature = select_best_feature_for_split(node.samples)
    # temperatureåœ¨æ ¹èŠ‚ç‚¹æœ€ä¼˜ï¼Œproduct_typeåœ¨å­èŠ‚ç‚¹æœ€ä¼˜
```

**2. å¤„ç†ç‰¹å¾äº¤äº’**
```python
# ä¸åŒè·¯å¾„ä¸‹åŒä¸€ç‰¹å¾çš„åˆ†è£‚é˜ˆå€¼å¯èƒ½ä¸åŒ
path_1 = ['temperature <= 26.0', 'humidity <= 45.0']  # ä½æ¸©ä¸‹å¯¹æ¹¿åº¦æ•æ„Ÿ
path_2 = ['temperature > 26.0', 'humidity <= 67.5']   # é«˜æ¸©ä¸‹æ¹¿åº¦é˜ˆå€¼æé«˜
```

**3. æ··åˆæ•°æ®ç±»å‹**
```python
# åŒæ—¶å¤„ç†æ•°å€¼ç‰¹å¾å’Œåˆ†ç±»ç‰¹å¾
numeric_split = f"{feature} <= {threshold}"      # temperature <= 26.0
categorical_split = f"{feature} âˆˆ {categories}"  # product_type âˆˆ {A, B}
```

#### ğŸ“ˆ ä¼˜åŠ¿åˆ†æ

**vs å•ç‰¹å¾åˆ†æ®µï¼š**
| å•ç‰¹å¾åˆ†æ®µ | å¤šç‰¹å¾åˆ†æ®µ |
|-----------|-----------|
| `temperature <= 25` | `temperature <= 26.0 ä¸” product_type âˆˆ {A}` |
| å¿½ç•¥ç‰¹å¾äº¤äº’ | è‡ªåŠ¨å‘ç°äº¤äº’æ¨¡å¼ |
| åˆ†æ®µç²—ç³™ | åˆ†æ®µç²¾ç»†ä¸”åˆç† |

**vs æ‰‹å·¥è§„åˆ™ï¼š**
| æ‰‹å·¥è§„åˆ™ | æ™ºèƒ½åˆ†æ®µ |
|---------|---------|
| éœ€è¦é¢†åŸŸä¸“å®¶ | æ•°æ®è‡ªåŠ¨é©±åŠ¨ |
| é™æ€é˜ˆå€¼ | åŠ¨æ€ä¼˜åŒ–é˜ˆå€¼ |
| å®¹æ˜“é—æ¼äº¤äº’ | ç³»ç»Ÿå‘ç°æ‰€æœ‰æœ‰æ•ˆäº¤äº’ |

#### ğŸ›ï¸ å‚æ•°æ§åˆ¶ç­–ç•¥

```python
# é˜²æ­¢è¿‡æ‹Ÿåˆçš„å…³é”®å‚æ•°
DecisionTreeRegressor(
    max_depth=3,              # é™åˆ¶æ ‘æ·±åº¦ï¼Œé¿å…è¿‡åº¦ç»†åˆ†
    min_samples_leaf=50,      # ç¡®ä¿æ¯ä¸ªåˆ†æ®µæœ‰è¶³å¤Ÿæ ·æœ¬
    min_samples_split=100,    # èŠ‚ç‚¹åˆ†è£‚çš„æœ€å°æ ·æœ¬æ•°
    max_features='sqrt'       # é™åˆ¶æ¯æ¬¡åˆ†è£‚è€ƒè™‘çš„ç‰¹å¾æ•°
)
```

**å‚æ•°æ•ˆæœï¼š**
- `max_depth=3`ï¼šæœ€å¤š3å±‚åˆ†è£‚ï¼Œå¾—åˆ°æœ€å¤š8ä¸ªåˆ†æ®µ
- `min_samples_leaf=50`ï¼šæ¯ä¸ªåˆ†æ®µè‡³å°‘50ä¸ªæ ·æœ¬ï¼Œä¿è¯ç»Ÿè®¡æ˜¾è‘—æ€§
- è‡ªåŠ¨å¹³è¡¡åˆ†æ®µç²’åº¦å’Œæ³›åŒ–èƒ½åŠ›

è¿™ç§å¤šç‰¹å¾åˆ†æ®µæœºåˆ¶ä½¿æˆ‘ä»¬èƒ½å¤Ÿå‘ç°å¤æ‚çš„ä¸šåŠ¡è§„å¾‹ï¼Œæ¯”å¦‚ï¼š
- **"ä½æ¸©ä¸”Aå‹äº§å“"** â†’ ä¸€ç§èƒ½è€—æ¨¡å¼
- **"é«˜æ¸©ä¸”é«˜æ¹¿åº¦"** â†’ å¦ä¸€ç§èƒ½è€—æ¨¡å¼
- **ç‰¹å¾äº¤äº’æ•ˆåº”** â†’ æ¸©åº¦å’Œäº§å“ç±»å‹çš„ç»„åˆå½±å“

è¿™å°±æ˜¯æˆ‘ä»¬çš„ç®—æ³•èƒ½å¤Ÿå‘ç°ä¼ ç»Ÿæ–¹æ³•æ— æ³•æ•æ‰çš„ç»†å¾®åˆ†æ®µæ¨¡å¼çš„å…³é”®æ‰€åœ¨ï¼

#### 2. æ··åˆç‰¹å¾ç±»å‹æ”¯æŒ
```python
# è‡ªåŠ¨è¯†åˆ«ç‰¹å¾ç±»å‹
if data[col].dtype == 'object':
    categorical_features.append(col)  # åˆ†ç±»ç‰¹å¾
elif pd.api.types.is_numeric_dtype(data[col]):
    numeric_features.append(col)      # æ•°å€¼ç‰¹å¾
```

**æ”¯æŒçš„ç‰¹å¾ç±»å‹**ï¼š
- **æ•°å€¼ç‰¹å¾**ï¼šæ¸©åº¦ã€ä»·æ ¼ã€é¢ç§¯ç­‰è¿ç»­å€¼
- **åˆ†ç±»ç‰¹å¾**ï¼šäº§å“ç±»å‹ã€åœ°åŒºã€å­£èŠ‚ç­‰ç¦»æ•£å€¼
- **æ··åˆæ•°æ®**ï¼šåŒæ—¶åŒ…å«æ•°å€¼å’Œåˆ†ç±»ç‰¹å¾

#### 3. äº¤å‰éªŒè¯è´¨é‡è¯„ä¼°
```python
# ä½¿ç”¨äº¤å‰éªŒè¯é¿å…è¿‡æ‹Ÿåˆ
cv_scores = cross_val_score(model, X_poly, y_poly, cv=3, scoring='r2')
avg_score = np.mean(cv_scores)
```

**å¯é æ€§ä¿è¯**ï¼šé€šè¿‡äº¤å‰éªŒè¯ç¡®ä¿å‘ç°çš„è§„åˆ™å…·æœ‰è‰¯å¥½çš„æ³›åŒ–èƒ½åŠ›ã€‚

## ğŸ“Š è¯¦ç»†ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šç©ºè°ƒèƒ½è€—åˆ†æ

#### è¾“å…¥æ•°æ® (`energy_data.csv`)
```csv
temperature,humidity,area,occupancy,ac_type,energy_cost
35,60,100,5,A,450
20,40,100,5,A,280
35,60,100,5,B,520
20,40,100,5,B,320
25,50,150,8,A,380
30,70,150,8,B,580
```

#### è¿è¡Œå‘½ä»¤
```bash
python discover_conditional_rules_optimal.py energy_data.csv
```

#### å‘ç°çš„è§„åˆ™
```
=== ä¼˜åŒ–ç‰ˆæ¡ä»¶è§„åˆ™å‘ç°ï¼ˆæ”¯æŒåˆ†ç±»ç‰¹å¾ï¼‰===

ç‰¹å¾ç±»å‹è¯†åˆ«:
  æ•°å€¼ç‰¹å¾: ['temperature', 'humidity', 'area', 'occupancy']
  åˆ†ç±»ç‰¹å¾: ['ac_type']
  å¯åˆ†æ®µç‰¹å¾: ['temperature', 'humidity', 'area', 'occupancy', 'ac_type']

æœ€ä¼˜ç‰¹å¾é…ç½®:
  åˆ†æ®µç‰¹å¾: ['temperature', 'ac_type']
  å¤šé¡¹å¼ç‰¹å¾: ['humidity', 'area', 'occupancy']
  ç»¼åˆè¯„åˆ†: 0.965

============================== æœ€ä¼˜è§„åˆ™è¯¦æƒ… ==============================

è§„åˆ™ 1:
  æ¡ä»¶: temperature <= 27.50 ä¸” ac_type âˆˆ {A}
  è§„åˆ™: energy_cost = 0.8 * humidity + 1.2 * area + 15 * occupancy + 50
  äº¤å‰éªŒè¯RÂ²: 0.984
  æ ·æœ¬æ•°: 45

è§„åˆ™ 2:
  æ¡ä»¶: temperature > 27.50 ä¸” ac_type âˆˆ {A}
  è§„åˆ™: energy_cost = 1.2 * humidity + 1.5 * area + 20 * occupancy + 80
  äº¤å‰éªŒè¯RÂ²: 0.975
  æ ·æœ¬æ•°: 38

è§„åˆ™ 3:
  æ¡ä»¶: ac_type âˆˆ {B}
  è§„åˆ™: energy_cost = 1.5 * humidity + 1.8 * area + 25 * occupancy + 100
  äº¤å‰éªŒè¯RÂ²: 0.968
  æ ·æœ¬æ•°: 52
```

#### ä¸šåŠ¡è§£é‡Š
- **Aå‹ç©ºè°ƒåœ¨ä½æ¸©æ—¶**ï¼šèƒ½è€—ä¸»è¦å—é¢ç§¯å’Œäººæ•°å½±å“ï¼Œæ¹¿åº¦å½±å“è¾ƒå°
- **Aå‹ç©ºè°ƒåœ¨é«˜æ¸©æ—¶**ï¼šæ‰€æœ‰å› ç´ çš„å½±å“éƒ½å¢å¼ºï¼Œç‰¹åˆ«æ˜¯æ¹¿åº¦
- **Bå‹ç©ºè°ƒ**ï¼šæ•´ä½“èƒ½è€—æ›´é«˜ï¼Œå¯¹æ‰€æœ‰å› ç´ éƒ½æ›´æ•æ„Ÿ

### ç¤ºä¾‹2ï¼šç”µå•†é”€å”®é¢„æµ‹

#### è¾“å…¥æ•°æ® (`sales_data.csv`)
```csv
price,marketing_budget,product_category,season,region,sales
100,50,Electronics,Summer,North,1200
100,50,Electronics,Winter,North,800
150,80,Clothing,Summer,South,2000
150,80,Clothing,Winter,South,2500
120,60,Home,Spring,East,1100
```

#### å‘ç°çš„è§„åˆ™
```
è§„åˆ™ 1:
  æ¡ä»¶: product_category âˆˆ {Electronics} ä¸” season âˆˆ {Summer}
  è§„åˆ™: sales = 8 * price + 12 * marketing_budget + 200

è§„åˆ™ 2:
  æ¡ä»¶: product_category âˆˆ {Clothing} ä¸” region âˆˆ {South}
  è§„åˆ™: sales = 6 * price + 18 * marketing_budget + 500

è§„åˆ™ 3:
  æ¡ä»¶: season âˆˆ {Winter}
  è§„åˆ™: sales = 4 * price + 15 * marketing_budget + 300
```

## ğŸš€ ä½¿ç”¨æŒ‡å—

### å®‰è£…ä¾èµ–
```bash
pip install pandas scikit-learn numpy
```

### åŸºæœ¬ä½¿ç”¨

#### 1. å®Œå…¨è‡ªåŠ¨åˆ†æ
```bash
python discover_conditional_rules_optimal.py your_data.csv
```

#### 2. æŒ‡å®šç›®æ ‡åˆ—
```bash
python discover_conditional_rules_optimal.py your_data.csv --target-col sales
```

#### 3. æ‰‹åŠ¨æŒ‡å®šç‰¹å¾ç±»å‹
```bash
python discover_conditional_rules_optimal.py your_data.csv \
    --split-features category region \
    --poly-features price marketing_budget
```

#### 4. è°ƒä¼˜å‚æ•°
```bash
python discover_conditional_rules_optimal.py your_data.csv \
    --max-depth 4 \
    --min-samples 30 \
    --max-combinations 200
```

### å‚æ•°è¯´æ˜

| å‚æ•° | è¯´æ˜ | é»˜è®¤å€¼ | å»ºè®® |
|------|------|--------|------|
| `--target-col` | ç›®æ ‡åˆ—å | æœ€åä¸€åˆ— | æ˜ç¡®æŒ‡å®šæ›´å¯é  |
| `--split-features` | åˆ†æ®µç‰¹å¾ | è‡ªåŠ¨æ£€æµ‹ | åˆ†ç±»ç‰¹å¾ä¼˜å…ˆ |
| `--poly-features` | å¤šé¡¹å¼ç‰¹å¾ | è‡ªåŠ¨æ£€æµ‹ | æ•°å€¼ç‰¹å¾ |
| `--max-depth` | å†³ç­–æ ‘æ·±åº¦ | 3 | æ•°æ®å¤æ‚æ—¶å¢å¤§ |
| `--min-samples` | æœ€å°æ ·æœ¬æ•° | 50 | æ•°æ®é‡å°æ—¶å‡å° |
| `--max-combinations` | æœ€å¤§ç»„åˆæ•° | 100 | ç‰¹å¾å¤šæ—¶å¢å¤§ |
| `--disable-exhaustive` | ç¦ç”¨ç©·ä¸¾ | False | å¤§æ•°æ®é›†æ—¶å¯ç”¨ |

## ğŸ“ˆ è¾“å‡ºç»“æœè§£è¯»

### è¯„ä¼°æŒ‡æ ‡

- **äº¤å‰éªŒè¯RÂ²**ï¼šæ¨¡å‹æ‹Ÿåˆè´¨é‡ï¼ˆ0-1ï¼Œè¶Šæ¥è¿‘1è¶Šå¥½ï¼‰
- **æ ·æœ¬æ•°**ï¼šè¯¥è§„åˆ™è¦†ç›–çš„æ•°æ®ç‚¹æ•°é‡
- **ç»¼åˆè¯„åˆ†**ï¼šè€ƒè™‘è´¨é‡å’Œè§„åˆ™æ•°é‡çš„ç»¼åˆåˆ†æ•°

### æ¡ä»¶æ ¼å¼

- **æ•°å€¼æ¡ä»¶**ï¼š`temperature <= 25.0`ã€`price > 100.0`
- **åˆ†ç±»æ¡ä»¶**ï¼š`category âˆˆ {A, B}`ã€`region âˆˆ {North}`
- **å¤åˆæ¡ä»¶**ï¼š`temperature <= 25.0 ä¸” category âˆˆ {A}`

### è§„åˆ™æ ¼å¼

- **çº¿æ€§è§„åˆ™**ï¼š`sales = 2 * price + 3 * marketing + 100`
- **ç®€åŒ–æ˜¾ç¤º**ï¼šç³»æ•°è‡ªåŠ¨å››èˆäº”å…¥ï¼Œæ¥è¿‘0çš„é¡¹è‡ªåŠ¨å¿½ç•¥

## ğŸ”§ é«˜çº§åŠŸèƒ½

### 1. ç‰¹å¾å·¥ç¨‹å»ºè®®

**æ¨èçš„åˆ†æ®µç‰¹å¾**ï¼š
- æ—¶é—´ç›¸å…³ï¼šå­£èŠ‚ã€æœˆä»½ã€å·¥ä½œæ—¥/å‘¨æœ«
- åˆ†ç±»å±æ€§ï¼šäº§å“ç±»å‹ã€åœ°åŒºã€ç”¨æˆ·ç­‰çº§
- é˜ˆå€¼ç‰¹å¾ï¼šä»·æ ¼æ®µã€å¹´é¾„æ®µã€æ”¶å…¥æ®µ

**æ¨èçš„å¤šé¡¹å¼ç‰¹å¾**ï¼š
- è¿ç»­æ•°å€¼ï¼šä»·æ ¼ã€é¢ç§¯ã€æ•°é‡ã€è¯„åˆ†
- è®¡ç®—ç‰¹å¾ï¼šæ¯”ç‡ã€å·®å€¼ã€ä¹˜ç§¯

### 2. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**å¤§æ•°æ®é›†å¤„ç†**ï¼š
```bash
# ä½¿ç”¨å¯å‘å¼æœç´¢æ›¿ä»£ç©·ä¸¾
python discover_conditional_rules_optimal.py large_data.csv --disable-exhaustive

# é™åˆ¶ç‰¹å¾ç»„åˆæ•°é‡
python discover_conditional_rules_optimal.py large_data.csv --max-combinations 50

# å¢å¤§æœ€å°æ ·æœ¬æ•°å‡å°‘è¿‡æ‹Ÿåˆ
python discover_conditional_rules_optimal.py large_data.csv --min-samples 100
```

**ç‰¹å¾æ•°é‡vsè®¡ç®—æ—¶é—´**ï¼š
| ç‰¹å¾æ•°é‡ | ç©·ä¸¾ç»„åˆæ•° | å¯å‘å¼ç»„åˆæ•° | é¢„ä¼°æ—¶é—´ |
|---------|-----------|------------|----------|
| 4ä¸ªç‰¹å¾ | 15 | 15 | < 1åˆ†é’Ÿ |
| 6ä¸ªç‰¹å¾ | 63 | 40 | < 8åˆ†é’Ÿ |
| 8ä¸ªç‰¹å¾ | 255 | 100 | < 20åˆ†é’Ÿ |
| 10ä¸ªç‰¹å¾ | 1023 | 100 | < 25åˆ†é’Ÿ |

### 3. ç»“æœéªŒè¯å»ºè®®

**è§„åˆ™å¯ä¿¡åº¦æ£€æŸ¥**ï¼š
1. **RÂ²åˆ†æ•°** > 0.7ï¼šé«˜å¯ä¿¡åº¦
2. **æ ·æœ¬æ•°é‡** > 30ï¼šç»Ÿè®¡æ˜¾è‘—æ€§
3. **ä¸šåŠ¡é€»è¾‘**ï¼šç¬¦åˆé¢†åŸŸçŸ¥è¯†

**å¸¸è§é—®é¢˜å¤„ç†**ï¼š
- **è¿‡æ‹Ÿåˆ**ï¼šå¢å¤§ `min-samples` å‚æ•°
- **è§„åˆ™å¤ªå°‘**ï¼šå‡å° `min-samples` æˆ–å¢å¤§ `max-depth`
- **è®¡ç®—å¤ªæ…¢**ï¼šä½¿ç”¨ `--disable-exhaustive` æˆ–å‡å° `max-combinations`

## ğŸ¯ åº”ç”¨åœºæ™¯

### å•†ä¸šåˆ†æ
- **ä»·æ ¼ç­–ç•¥**ï¼šä¸åŒäº§å“/åœ°åŒºçš„ä»·æ ¼æ•æ„Ÿåº¦
- **è¥é”€æ•ˆæœ**ï¼šä¸åŒç”¨æˆ·ç¾¤ä½“çš„è¥é”€ROI
- **éœ€æ±‚é¢„æµ‹**ï¼šå­£èŠ‚æ€§/åŒºåŸŸæ€§éœ€æ±‚æ¨¡å¼

### è¿è¥ä¼˜åŒ–
- **èµ„æºé…ç½®**ï¼šä¸åŒæ¡ä»¶ä¸‹çš„èµ„æºéœ€æ±‚è§„å¾‹
- **æˆæœ¬æ§åˆ¶**ï¼šå½±å“æˆæœ¬çš„å…³é”®å› ç´ åˆ†æ
- **æ•ˆç‡æå‡**ï¼šæ“ä½œæ¡ä»¶ä¸æ•ˆç‡çš„å…³ç³»

### ç§‘å­¦ç ”ç©¶
- **å®éªŒåˆ†æ**ï¼šä¸åŒæ¡ä»¶ä¸‹çš„å› æœå…³ç³»
- **æ¨¡å¼å‘ç°**ï¼šæ•°æ®ä¸­çš„éšè—è§„å¾‹
- **å‡è®¾éªŒè¯**ï¼šç†è®ºæ¨¡å‹çš„æ•°æ®æ”¯æ’‘

## ğŸ”— æŠ€æœ¯ç»†èŠ‚

### ç®—æ³•å¤æ‚åº¦
- **æ—¶é—´å¤æ‚åº¦**ï¼šO(C(n,k) Ã— m Ã— log(m))ï¼Œå…¶ä¸­nä¸ºç‰¹å¾æ•°ï¼Œkä¸ºæœ€å¤§åˆ†æ®µç‰¹å¾æ•°ï¼Œmä¸ºæ ·æœ¬æ•°
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(m)
- **å®é™…æ€§èƒ½**ï¼šé€šè¿‡å¯å‘å¼ä¼˜åŒ–ï¼Œå®é™…è¿è¡Œæ—¶é—´è¿œä½äºç†è®ºä¸Šç•Œ

### ç†è®ºåŸºç¡€
- **å†³ç­–æ ‘åˆ†æ®µ**ï¼šåŸºäºä¿¡æ¯å¢ç›Šçš„æœ€ä¼˜åˆ†å‰²
- **çº¿æ€§å›å½’**ï¼šæœ€å°äºŒä¹˜æ³•æ‹Ÿåˆ
- **äº¤å‰éªŒè¯**ï¼šKæŠ˜äº¤å‰éªŒè¯è¯„ä¼°æ³›åŒ–èƒ½åŠ›
- **ç»„åˆä¼˜åŒ–**ï¼šç©·ä¸¾æœç´¢ + å¯å‘å¼å‰ªæ

### æ‰©å±•æ–¹å‘
- **éçº¿æ€§é¡¹**ï¼šæ”¯æŒäºŒæ¬¡é¡¹ã€äº¤äº’é¡¹
- **æ­£åˆ™åŒ–**ï¼šRidge/Lassoå›å½’é˜²æ­¢è¿‡æ‹Ÿåˆ
- **é›†æˆæ–¹æ³•**ï¼šå¤šä¸ªå†³ç­–æ ‘çš„ç»“æœèåˆ
- **åœ¨çº¿å­¦ä¹ **ï¼šå¢é‡æ›´æ–°è§„åˆ™

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœæ‚¨åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­é‡åˆ°é—®é¢˜ï¼Œè¯·æ£€æŸ¥ï¼š

1. **æ•°æ®æ ¼å¼**ï¼šç¡®ä¿CSVæ ¼å¼æ­£ç¡®ï¼Œç¬¬ä¸€è¡Œä¸ºåˆ—å
2. **ç‰¹å¾ç±»å‹**ï¼šæ•°å€¼ç‰¹å¾ç”¨äºå¤šé¡¹å¼ï¼Œåˆ†ç±»ç‰¹å¾ç”¨äºåˆ†æ®µ
3. **æ ·æœ¬æ•°é‡**ï¼šç¡®ä¿æ¯ä¸ªåˆ†æ®µæœ‰è¶³å¤Ÿçš„æ ·æœ¬æ•°
4. **å‚æ•°è®¾ç½®**ï¼šæ ¹æ®æ•°æ®è§„æ¨¡è°ƒæ•´å‚æ•°

**å¸¸è§é”™è¯¯åŠè§£å†³æ–¹æ¡ˆ**ï¼š
- `é”™è¯¯: æ²¡æœ‰è¶³å¤Ÿçš„ç‰¹å¾` â†’ æ£€æŸ¥æ•°æ®æ˜¯å¦åŒ…å«æ•°å€¼ç‰¹å¾
- `æœªå‘ç°æœ‰æ•ˆçš„æ¡ä»¶è§„åˆ™` â†’ å‡å° `min-samples` æˆ–å¢å¤§ `max-depth`
- `è®¡ç®—æ—¶é—´è¿‡é•¿` â†’ ä½¿ç”¨ `--disable-exhaustive` å‚æ•°

---

*è¿™ä¸ªå·¥å…·çš„æ ¸å¿ƒä»·å€¼åœ¨äºè‡ªåŠ¨å‘ç°æ•°æ®ä¸­çš„åˆ†æ®µæ¨¡å¼ï¼Œä¸ºä¸šåŠ¡å†³ç­–æä¾›å¯è§£é‡Šçš„é‡åŒ–è§„åˆ™ã€‚é€šè¿‡æ™ºèƒ½çš„ç‰¹å¾ç»„åˆä¼˜åŒ–ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ‰¾åˆ°æœ€èƒ½æ­ç¤ºæ•°æ®æœ¬è´¨è§„å¾‹çš„æ¡ä»¶å¤šé¡¹å¼å…³ç³»ã€‚* 